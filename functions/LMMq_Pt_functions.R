# ------- R functions ------ ----

# what observed history is generated by a latent one ?
latentObsGenerates <- function(histo, vectHists){
  index2 <- which(histo == 2)
  hist2 <- histo
  hist2[index2] <- 0
  
  a <- integer(length(vectHists))
  
  if(any(hist2 > 0)){
    a[which(vectHists == deparse(hist2))] <- 1
  }
  
  if(length(index2) > 0){
    for(i in index2){
      histErr <- numeric(length(histo))
      histErr[i] <- 1
      a[which(vectHists == deparse(histErr))] <- 1
    }
  }
  
  a
}

# Matrix A (y = Ax)
getA <- function(latentObservation, observation){
  vectHists <- apply(observation, 1, deparse)
  A <- t(apply(latentObservation, 1, latentObsGenerates, 
               vectHists = vectHists))
  t(A)[-which(vectHists==deparse(numeric(S))),]
}


# Simulation of data
simulCapture <- function(N, S, pcapture){
  
  cr <- matrix(ncol = S, nrow = N, data = 0) # Matrix of capture NbIndiv * NbSample
  
  for(i in 1:N){
    for(t in 1:S){
      if(runif(1) < pcapture[t]) #capture
          cr[i,t] <- 1 # Adding a succesful capture to cr
    }
  }
  
  return(cr)
  
}


# Simulation of data
simulIdentification <- function(captureData, a, b, tau){
  
  N <- nrow(captureData)
  
  cr <- matrix(ncol = S, nrow = sum(captureData)+N, data = 0)
  tau2 <- u <- cr
  cr[1:N, ] <- captureData
  tau2[1:N, ] <- tau
  
  n_err_made <- 0
  
  for(i in 1:N){
    for(t in 1:S){
      if(cr[i, t] > 0){
        u[i, t] <- rnorm(1, a * tau[i, t] + b, 1)
        if(u[i, t] < 0){
          n_err_made <- n_err_made + 1
          n <- N + n_err_made
          cr[i, t] <- 0
          cr[n, t] <- 1
          tau2[n, t] <- tau[i, t]
          tau2[i, t] <- 0
          u[n, t] <- u[i, t]
          u[i, t] <- 0
        }
      }
    }
    
  }
  end <- N + n_err_made
  cr <- cr[1:end, ]
  tau2 <- tau2[1:end, ]
  u <- u[1:end, ]
  
  return(list(observed = cr, tau = tau2, u_tilde = u))
  
}

# Adds error to generate different xInit
addError <- function(tau, latentObservation, latentIndex, S){
  
  skip <- TRUE
  tauProp <- tau
  latentObsProp <- latentObservation
  latentIdxProp <- latentIndex
  
  existing <- latentIndex > 0
  
  # What time is available for adding an error
  available_t <- logical(S)
  available_nu0 <- logical(S)
  for(t in 1:S){
    if(any(latentIndex == 1+3^(t-1))) 
      available_t[t] <- TRUE
    if(any( latentObsProp[existing, t] == 0 )) 
      available_nu0[t] <- TRUE
  }
  available_fully <- which(available_t*available_nu0 == 1)
  if(any(available_fully > 0)){
    skip <- FALSE
    # sample t, nu0 and nu1
    t <- sample(available_fully, 1)
    which_nu0 <- nimNumeric()
    which_nu0 <- which(((latentObsProp[, t] == 0) * existing) > 0)
    nu0i <- nimSample(which_nu0)
    nu0 <- latentObsProp[nu0i, ]
    all_nu1i <- nimNumeric()
    all_nu1i <- which(latentIdxProp == 1+3^(t-1))
    als <- tauProp[all_nu1i, t]
    nu1i <- all_nu1i[rcat(1, als)]
    nu2 <- nu0
    nu2[t] <- 2
    # update nu0 as nu2
    latentIdxProp[nu0i] <- nimGetLatentIndex(nu2)
    latentObsProp[nu0i, t] <- 2
    tauProp[nu0i, t] <- tauProp[nu1i, t]
    # delete nu1
    latentIdxProp[nu1i] <- 0
    latentObsProp[nu1i, t] <- 0
    tauProp[nu1i, t] <- 0
  }
  
  if(!skip) 
    return(list(latObs=latentObsProp, latIdx=latentIdxProp,
                tau=tauProp, err=1))
  else return(list(latObs=latentObservation, latIdx=latentIndex,
                   tau=tau, err=0))
}

# 
getTrueLatent <- function(capture_data, res_observed, tau_values, n){
  # create True latent histories
  S <- ncol(capture_data)
  N <- nrow(capture_data)
  latObsTrue <- matrix(ncol = S, nrow = n, data = 0)
  latObsTrue[1:nrow(dta_observed), ] <- res_observed$observed
  latObsTrue[1:N, ][which((latObsTrue[1:N, ] - capture_data) != 0)] <- 2 
  latObsTrue[501:nrow(latObsTrue), ] <- 0
  sum(apply(latObsTrue, 1, function(h) (sum(h)==2)*(sum(h > 0)==1) ))
  # create True tau
  tauTrue <- matrix(ncol = S, nrow = n, data = 0)
  tauTrue[1:N, ] <- capture_data
  tauTrue[which(tauTrue > 0)] <- tau_values
  # create True u
  uTrue <- matrix(ncol = S, nrow = n, data = 0)
  uTrue[1:nrow(res_observed$u_tilde), ] <- res_observed$u_tilde
  for(i in 1:500){
    for(t in 1:S){
      if(latObsTrue[i, t] == 2){
        uTrue[i, t] <- res_observed$u_tilde[which(res_observed$tau == tauTrue[i, t])]
      }
    }
  }
  uTrue[501:nrow(uTrue), ] <- 0
  # create True latent index
  latIdxTrue <- apply(latObsTrue, 1, nimGetLatentIndex)
  latIdxTrue[which(latIdxTrue == 1)] <- 0
  latIdxTrue[which(latIdxTrue == 0)[1:sum(apply(capture_data, 1, sum) == 0)]] <- 1
  
  list(latObs = latObsTrue, latIdx = latIdxTrue, tau = tauTrue, u = uTrue)
}


# ------ Functions ------ ------


# sample uniform double function compiled
nimSample <-  nimbleFunction(
  run = function(x = double(1)){
    l <- length(x)
    ind <- rcat(1, nimRep(1/l, l))
    nsamp <- x[ind]
    
    returnType(double(0))
    return(nsamp)
  })
# CnimSample <- compileNimble(nimSample)

nimGetLatentIndex <- nimbleFunction(
  run = function(h = double(1)){
    s <- 1 
    for(t in 1:length(h)) s <- s + h[t]*3^(t-1)
    return(s)
    returnType(double(0))
  })
# CnimGetLatentIndex <- compileNimble(nimGetLatentIndex)

nimGetObsIndex <- nimbleFunction(
  run = function(h = double(1)){
    s <- 1 
    for(t in 1:length(h)) s <- s + h[t]*2^(t-1)
    return(s)
    returnType(double(0))
  })
# CnimGetLatentIndex <- compileNimble(nimGetLatentIndex)

# sample from truncated normal distribution
nimRnormTrunc <- nimbleFunction(
  run = function(n = double(0), 
                 mu=double(0, default = 0),
                 sd=double(0, default = 1), 
                 lower=double(0, default=-Inf), 
                 upper=double(0, default=Inf)){
    
    # inverse transformation method
    
    # Generate 10,000 uniform distributed sample from [0, 1]
    q_simulation = runif(n, min=0, max=1)
    
    # Put in back to inverse distribution
    q_temp_simulation <- (pnorm(lower, mean = mu, sd=sd ) + 
                            q_simulation * (pnorm(upper, mean = mu, sd=sd) - 
                                              pnorm(lower, mean = mu, sd=sd)))
    
    res <- qnorm(q_temp_simulation, 
                 mean = mu, sd=sd)
    
    return(res)
    returnType(double(1))
  }
)

# cNimRnormTrunc <- compileNimble(nimRnormTrunc)


nimGetUtilde <- nimbleFunction(
  run = function(tau = double(1), u = double(1), a = double(0), b = double(0)){
    utilde <- nimNumeric(length(tau))
    for(i in 1:length(tau)){
      if(u[i] == 1) 
        utilde[i] <- nimRnormTrunc(1, a * tau[i] + b, lower = 0)[1]
      else
        utilde[i] <- nimRnormTrunc(1, a * tau[i] + b, upper = 0)[1]
    }
    return(utilde)
    returnType(double(1))
  }
)


nimEstimPriorGen <- nimbleFunction(
  setup = function(tau, id, prior_mua, prior_sda, prior_mub, prior_sdb) {
    
    nb_id <- length(tau)
    
    a <- prior_mua
    b <- prior_mub
    
    sda <- sqrt( ( 1/(prior_sda^2) + sum(tau^2) )^(-1) )
    sdb <- sqrt( prior_sdb^2 / (nb_id*prior_sdb^2 + 1) )
  },
  run = function(niter = double(0), nburn = double(0)) {
    
    res <- nimMatrix(ncol = 2, nrow = niter+nburn)
    
    for(it in 1:(niter+nburn)){
      
      utilde <- nimGetUtilde(tau, id, a, b)
      mua <- sda^2 * (prior_mua/(prior_sda^2) + sum( tau * (utilde - b) ) )
      a <<- rnorm(1, mua, sda)
      
      utilde <- nimGetUtilde(tau, id, a, b)
      mub <- sdb^2 * (prior_mub/(prior_sdb^2) + sum(utilde - a *  tau))
      b <<- rnorm(1, mub, sdb)
      
      res[it, ] <- c(a, b)
    }
    
    return(res[(nburn+1):(nburn+niter), ])
    returnType(double(2))
  },
  methods = list(
    reset = function () {} )
)

